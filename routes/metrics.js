const express = require('express');
const router = express.Router();
const { getInstance } = require('../middleware/performanceMetrics');
const HealthCheckService = require('../middleware/healthCheck');
const logger = require('../utils/logger');

/**
 * Endpoint avanzado para métricas de performance
 * Combina métricas del sistema de performance con health checks
 */
router.get('/performance', async (req, res) => {
    try {
        const performanceMetrics = getInstance();
        const metrics = performanceMetrics.getAllMetrics();
        
        res.json({
            success: true,
            metrics,
            collectedAt: new Date().toISOString()
        });
        
    } catch (error) {
        logger.error('MetricsRoute', 'Error getting performance metrics', { error });
        res.status(500).json({
            success: false,
            error: 'Error retrieving performance metrics'
        });
    }
});

/**
 * Endpoint para métricas en formato Prometheus
 */
router.get('/prometheus', async (req, res) => {
    try {
        const performanceMetrics = getInstance();
        
        // Obtener métricas de performance
        const prometheusMetrics = performanceMetrics.getPrometheusMetrics();
        
        // Obtener métricas adicionales de servicios
        const [dbHealth, redisHealth, queueHealth, systemHealth] = await Promise.allSettled([
            HealthCheckService.checkDatabase(),
            HealthCheckService.checkRedis(),
            HealthCheckService.checkQueues(),
            HealthCheckService.checkSystemResources()
        ]);
        
        const additionalMetrics = [
            '# Database metrics',
            `db_connections_total ${dbHealth.value?.pool?.totalConnections || 0}`,
            `db_connections_idle ${dbHealth.value?.pool?.idleConnections || 0}`,
            `db_connections_waiting ${dbHealth.value?.pool?.waitingClients || 0}`,
            `db_response_time_ms ${dbHealth.value?.responseTime || 0}`,
            '',
            '# Redis metrics', 
            `redis_available ${redisHealth.value?.status === 'healthy' ? 1 : 0}`,
            `redis_response_time_ms ${redisHealth.value?.responseTime || 0}`,
            '',
            '# Service status',
            `service_status_healthy 1`,
            `metrics_timestamp ${Date.now()}`
        ].join('\n');
        
        const fullMetrics = [
            '# WhatsApp Bot Performance Metrics',
            '# Generated by bot-bsl performance monitoring',
            '',
            prometheusMetrics,
            '',
            additionalMetrics
        ].join('\n');
        
        res.set('Content-Type', 'text/plain; version=0.0.4; charset=utf-8');
        res.status(200).send(fullMetrics);
        
    } catch (error) {
        logger.error('MetricsRoute', 'Error generating Prometheus metrics', { error });
        res.status(500).send('# Error generating metrics\n');
    }
});

/**
 * Endpoint para reset de métricas (solo para desarrollo/testing)
 */
router.post('/reset', (req, res) => {
    try {
        if (process.env.NODE_ENV === 'production') {
            return res.status(403).json({
                success: false,
                error: 'Metrics reset not allowed in production'
            });
        }
        
        const performanceMetrics = getInstance();
        performanceMetrics.reset();
        
        logger.info('MetricsRoute', 'Performance metrics reset', {
            requestedBy: req.ip,
            timestamp: new Date().toISOString()
        });
        
        res.json({
            success: true,
            message: 'Performance metrics reset successfully'
        });
        
    } catch (error) {
        logger.error('MetricsRoute', 'Error resetting metrics', { error });
        res.status(500).json({
            success: false,
            error: 'Error resetting metrics'
        });
    }
});

/**
 * Endpoint para estadísticas específicas de endpoints
 */
router.get('/endpoints', (req, res) => {
    try {
        const performanceMetrics = getInstance();
        const allMetrics = performanceMetrics.getAllMetrics();
        
        const endpointStats = Object.entries(allMetrics.requests.byEndpoint)
            .map(([endpoint, stats]) => ({
                endpoint,
                requests: stats.count,
                avgResponseTime: Math.round(stats.avgTime),
                errors: stats.errors,
                errorRate: stats.count > 0 ? ((stats.errors / stats.count) * 100).toFixed(1) + '%' : '0%'
            }))
            .sort((a, b) => b.requests - a.requests);
        
        res.json({
            success: true,
            endpoints: endpointStats,
            totalEndpoints: endpointStats.length,
            collectedAt: new Date().toISOString()
        });
        
    } catch (error) {
        logger.error('MetricsRoute', 'Error getting endpoint stats', { error });
        res.status(500).json({
            success: false,
            error: 'Error retrieving endpoint statistics'
        });
    }
});

module.exports = router;